# My Time

To implement this project, I took advantage of a lot of resources that already existed and found a way to combine them. The main tools I used were JTAppleCalendar and SQLite.swift, two GitHub projects that allowed me to recreate a calendar and interact with a SQL database without reinventing the wheel, and I wanted to make sure I acknowledged the helpfulness of both of those open source projects in allowing me to create the app that I wanted to.

While there were many challenges in learning Swift and dealing with the foreign issues of Xcode, one of the main problems that I solved were how I could connect the calendar and table view so that when I clicked a date the table view was updated accordingly. I tried many different solutions, including delegates and protocols, but eventually found that I could use the NotificationCenter within the app to send a notification from the calendar's view controller that the table view controller would be listening for. Under the hood, then, the calendar view controller sends a notification whenever a new date is selected, and when the table view controller hears that notification, it reloads the table view so as to update to display the events and assignments of the selected date as opposed to the previously selected one.

Another big problem was figuring out not only how to initially set up the database, but how to alter it after it was created. Because the database was only created once instead of every time, this involved adding lines of code to add a column and add values to that column and then deleting them after one run in order to avoid error. Each time a new event is added or deleted, it is added or deleted from the database, from an array called allEvents, and from the minutes it takes up in the hash table that represents the map of times free or busy. The database is loaded into this array each time the app is run, thus the events are added to the array so that the events show up in the view right away, as it is the array that is essentially being "queried" within one run of the app to find the events that match the selected date.

Under the hood, assignments and events are the same struct (Event), each with a due date, a date, a time needed (or length), a name, a type, an id (for hthe database), and a date. For events, dates and due dates are the same, but for assignments, due dates are added to the name while dates are the time the program actually schedules the assignment in. Though they both of the same struct, they often needed separate functions with slightly different parameters due to the difference in the purpose of date/due date for events vs. assignments. In order to schedule in To Dos, there is essentially a hash table that is created after the events from the database are retrieved that cycles through each event/assignment and sets the value of that key (the date to the minute) equal to true, thus creating a log of every minute in which there is something already scheduled. So, when the program looks to schedule in a new To Do, it iterates through from the current time until the time it is due looking for the first consecutive amount of minutes that adds up to the time needed, setting the time found variable back to zero whenever it finds an event (i.e. when that date/time is true in the allTime array).

Lastly, you will see there is some basic set up for other attributes in the code for a To Do (i.e. timeOfDay and priority). These choices are currently hidden to the user, but the set up exists because the next step would be to be able to slot in assignments not only based on when they are do and the events you already have but also the time of day you would like to do these (i.e. morning, afternoon, night) as well as how important it is to you (higher priority means it will slot it in sooner, maybe bumping a less important to do later in the day or week). I did not get a chance to implement this, but I hope to in the future, and that is why I left the basic structure for it.
